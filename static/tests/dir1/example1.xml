<?xml version="1.0" encoding="UTF-8"?>
<document 
   xmlns="https://iead.ittl.gtri.org/wr24/doc/2011-09-30-2258"
   xmlns:sch="http://purl.oclc.org/dsdl/schematron"
   >
  <title>National Information Exchange Model Naming and Design Rules</title>
  <version>3.0</version>
  <date>2012-09-11</date>
  <author>NIEM Technical Architecture Committee (NTAC)</author>
  <blurbSet id="ref"/>
  <blurbSet id="ext"/>
  <blurbSet id="sub"/>
  <blurbSet id="ins"/>
  <subsection>
    <title>Contents</title>
    <tableOfContents/>
  </subsection>
  <section>
    <title>RFC 2119 Terminology</title>
    <p>Within normative content (rules and definitions), the key words MUST,
      MUST NOT, REQUIRED, SHALL, SHALL NOT, SHOULD, SHOULD NOT, RECOMMENDED, MAY,
      and OPTIONAL in this document are to be interpreted as described in
      <ref idref="RFC2119"/>.</p>
  </section>
  <section>
    <title>Use of namespaces</title>
    <p>The following namespace prefixes are used consistently within this
    specification:</p>
    <ul>
      <li><p><code>xs:</code> The namespace for the XML Schema definition language
      as defined by <ref idref="XMLSchemaStructures"/> and
      <ref idref="XMLSchemaDatatypes"/>, <code>http://www.w3.org/2001/XMLSchema</code>.</p></li>

      <li><p><code>xsi:</code> The namespace of attributes defined by
      <ref idref="XMLSchemaStructures"/> for direct use in XML
      documents, <code>http://www.w3.org/2001/XMLSchema-instance</code>.</p></li>

      <li><p><code>sch:</code> The Schematron namespace URI, as defined by
      <ref idref="Schematron"/>, <code>http://purl.oclc.org/dsdl/schematron</code>.</p></li>

      <li><p><code>nf:</code> The namespace defined by this specification for XPath
      functions, <code>http://reference.niem.gov/niem/specification/naming-and-design-rules/3.0/#NDRFunctions</code>.</p></li>

      <li><p><code>ct:</code> The namespace defined by <ref idref="CTAS"/> for
      the <code>conformanceTargets</code> attribute, <code>http://release.niem.gov/niem/conformanceTargets/3.0/</code>.</p></li>

    </ul>
    
  </section>
  <section>
    <title>Normative XPath functions</title>
    <p>The following XPath functions are defined normatively when used within
    Schematron by this specification:</p>
    <ul>
      <li>
        <p><code>nf:root($element as element()) as element()</code>: Yields the
        root element for the XML document in which <code>$element</code>
        occurs.</p>

        <p>This function provides the ability for a validator to consolidate
        multiple XML Schema documents and XML instance documents into a single
        XML document, which may simplify validation, and allow for
        preprocessing of <code>xs:include</code> elements.</p>
      </li>
    </ul>
  </section>
  <section>
    <title>Normative Schematron namespace declarations</title>
    <p>The following Schematron namespace declarations are considered normative
    for the Schematron rules and supporting code within this specification:</p>
    <figure>
      <title>Normative Schematron namespace declarations</title>
      <pre><xmlBlurb id="schematron-ns-decl" memberOf="ref ext sub">
<sch:ns prefix="xs" uri="http://www.w3.org/2001/XMLSchema"/>
<sch:ns prefix="xsl" uri="http://www.w3.org/1999/XSL/Transform"/>
<sch:ns prefix="nf" uri="http://reference.niem.gov/niem/specification/naming-and-design-rules/3.0/#NDRFunctions"/>
<sch:ns prefix="ct" uri="http://release.niem.gov/niem/conformanceTargets/3.0/"/>
<sch:ns prefix="xsi" uri="http://www.w3.org/2001/XMLSchema-instance"/>
      </xmlBlurb></pre>
    </figure>
  </section>
  <section>
    <title>Conformance targets</title>

    <section>
      <title>Conformance targets defined</title>

      <p>Within this document, the term <em>conformance target</em> is as
        defined by <ref idref="CTAS"/>.</p>

      <p>The following conformance targets are established by this specification:</p>
      
      <definition term="reference schema document">
        <p>A <strong>reference schema document</strong> is an XML Schema
          document that is intended to provide the authoritative definitions
          of broadly reusable data components.  It is a conformance target
          of this specification. A reference schema document MUST conform to
          all rules of this specification that apply to this conformance
          target.</p>
      </definition>
      
      <definition term="extension schema document">
        <p>An <strong>extension schema document</strong> is an XML Schema
          document that is intended to provide definitions of data
          components that are intended for reuse within a more narrow scope
          than reference schema documents.  It is a conformance target of
          this specification. An extension schema document MUST conform to
          all rules of this specification that apply to this conformance
          target.</p>
      </definition>

      <definition term="subset schema document">
        <p>A <strong>subset schema document</strong> is an XML Schema
          document that is intended to define, for use within an information
          exchange, a narrow view of data components that are
          authoritatively defined by another schema document. It is a
          conformance target of this specification. A subset schema document
          MUST conform to all rules of this specification that apply to this
          conformance target.</p>
      </definition>

      <definition term="conformant schema document set">
        <p>A <strong>conformant schema document set</strong> is a collection
          of XML Schema documents that together are capable of validating a
          conformant instance XML document. It is a conformance target of this
          specification. A subset schema document MUST conform to all rules of
          this specification that apply to this conformance target.</p>
      </definition>

      <definition term="conformant instance XML document">
        <p>A <strong>conformant instance XML document</strong> is an XML
          document that is an instance of a conformant schema document set.
          It is a conformance target of this specification. A subset schema
          document MUST conform to all rules of this specification that apply
          to this conformance target.</p>
      </definition>
    </section>
    <section>
      <title>Applicability of rules to conformance targets</title>

      <p>Rules within this document are annotated with conformance target
        codes. Each rule may be annotated with one or more codes for a
        conformance target. A rule within this document that is annotated with
        one of the following codes applies to the corresponding conformance
        target.</p>

      <table id="TableCodesRepresentingConformanceTargets">
        <title>Codes Representing Conformance Targets</title>
        <theadr>
          <th>Code</th>
          <th>Conformance target</th>
        </theadr>
        <tr>
          <td>REF</td>
          <td>Reference schema document</td>
        </tr>
        <tr>
          <td>EXT</td>
          <td>Extension schema document</td>
        </tr>
        <tr>
          <td>SUB</td>
          <td>Subset schema document</td>
        </tr>
        <tr>
          <td>SET</td>
          <td>Conformant schema document set</td>
        </tr>
        <tr>
          <td>INS</td>
          <td>Conformant instance XML document</td>
        </tr>
      </table>
    </section>

    <section>
      <title>Conformance target identifiers</title>

      <p>The term <em>conformance target identifier</em> is defined by
        <ref idref="CTAS"/>.</p>

      <rule applicability="REF EXT SUB">
        <pre><xmlBlurb id="ctas-conformant-document" memberOf="ref ext sub">
<sch:pattern>
  <sch:rule context="*[. is nf:root(.)]">
    <sch:report test="true()">The document MUST be a conformant document as defined by the NIEM Conformance Targets Attribute Specification.</sch:report>
  </sch:rule>
</sch:pattern>
        </xmlBlurb></pre>
      </rule>

      <p>See <ref idref="CTAS"/> for the normative definition of conformant document.</p>

      <figure>
        <title>Abstract pattern supporting rules</title>
        <pre><xmlBlurb id="sch-pattern-2" memberOf="ref ext sub">
<sch:pattern abstract="true" id="require-effective-conformance-target">
  <sch:rule context="*[. is nf:root(.)]">
    <sch:assert test="$uri = tokenize(normalize-space(.//@ct:conformanceTargets)[1], ' ')">
      >The document MUST have an effective conformance target identifier of $uri.</sch:assert>
  </sch:rule>
</sch:pattern>
        </xmlBlurb></pre>
      </figure>

      <rule applicability="REF">
        <pre><xmlBlurb id="require-effective-conformance-target-ref" memberOf="ref">
<sch:pattern is-a="require-effective-conformance-target">
  <sch:param name="uri" value="'http://reference.niem.gov/niem/specification/naming-and-design-rules/3.0/#ReferenceSchemaDocument'"/>
</sch:pattern>          
        </xmlBlurb></pre>
      </rule>

      <rule applicability="EXT">
        <pre><xmlBlurb id="require-effective-conformance-target-ext" memberOf="ext">
<sch:pattern is-a="require-effective-conformance-target">
  <sch:param name="uri" value="'http://reference.niem.gov/niem/specification/naming-and-design-rules/3.0/#ExtensionSchemaDocument'"/>
</sch:pattern>          
        </xmlBlurb></pre>
      </rule>

      <rule applicability="SUB">
        <pre><xmlBlurb id="require-effective-conformance-target-sub" memberOf="sub">
<sch:pattern is-a="require-effective-conformance-target">
  <sch:param name="uri" value="'http://reference.niem.gov/niem/specification/naming-and-design-rules/3.0/#SubsetSchemaDocument'"/>
</sch:pattern>          
        </xmlBlurb></pre>
      </rule>
    </section>
  </section>
  <section>
    <title>Conformance to standards</title>
    <section>
      <title>Conformance to XML</title>
      <rule applicability="REF EXT SUB INS">
        <pre><xmlBlurb memberOf="ref ext sub ins" id="well-formed-xml">
<sch:pattern>
  <sch:rule context="*[. is nf:root(.)]">
    <sch:report test="true()">The document MUST be a well-formed XML document, as defined by Extensible Markup Language.</sch:report>
  </sch:rule>
</sch:pattern>
        </xmlBlurb></pre>
      </rule>
      <p>See <ref idref="XML"/> for the normative definition of <em>well-formed XML document</em>.</p>
    </section>
    <section>
      <title>Conformance to XML Namespaces</title>
      <rule applicability="REF EXT SUB INS">
        <pre><xmlBlurb memberOf="ref ext sub ins" id="namespace-well-formed">
<sch:pattern>
  <sch:rule context="*[. is nf:root(.)]">
    <sch:report test="true()">The document MUST be namespace-well-formed.</sch:report>
  </sch:rule>
</sch:pattern>            
        </xmlBlurb></pre>
      </rule>

      <p>The term <em>namespace-well-formed</em> is normatively defined by
        <ref idref="XMLNamespaces"/> and <ref idref="XMLNamespacesErrata"/>.</p>

      <rule applicability="REF EXT SUB INS">
        <pre><xmlBlurb memberOf="ref ext sub ins" id="namespace-valid">
<sch:pattern>
  <sch:rule context="*[. is nf:root(.)]">
    <sch:report test="true()">The document MUST be namespace-valid.</sch:report>
  </sch:rule>
</sch:pattern>            
        </xmlBlurb></pre>
      </rule>
        <p>The term <em>namespace-valid</em> is normatively defined by
          <ref idref="XMLNamespaces"/> and <ref idref="XMLNamespacesErrata"/>.</p>
    </section>

    <section>
      <title>Conformance to XML Schema</title>
      <rule applicability="REF EXT SUB">
        <p>The document MUST be a <em>schema document</em>, as defined by
          <ref idref="XMLSchemaStructures"/>.</p>
      </rule>
      <rule applicability="REF EXT SUB">
        <pre><xmlBlurb memberOf="ref ext sub" id="root-element-is-xs-schema">
<sch:pattern>
  <sch:rule context="*[. is nf:root(.)]">
    <sch:assert test="exists(self::xs:schema)"
      >The document element of the document MUST be {http://www.w3.org/2001/XMLSchema}schema.</sch:assert>  
  </sch:rule>
</sch:pattern>
        </xmlBlurb></pre>
      </rule>
    </section>
  </section>
  <section>
    <title>Documented components</title>
    <definition term="documented component">

      <p>In a NIEM-conformant schema, a <strong>documented component</strong> is
      an XML Schema component that has an associated data definition. Each
      documented component has a textual definition, so that the component may
      be well-understood. A schema that does not document a component
      accordingly is not NIEM-conformant.</p>

    </definition>

    <definition term="data definition">

      <p>The <strong>data definition</strong> of a documented component is the
      content of the first occurrence of the
      element <code>{http://www.w3.org/2001/XMLSchema}documentation</code> that is an immediate child
      of an occurrence of an element <code>{http://www.w3.org/2001/XMLSchema}annotation</code> that
      is an immediate child of the element that defines the component.</p>

    </definition>

    <rule applicability="REF EXT">

      <p>Within a NIEM-conformant schema, the data definition provided for each
      documented component SHALL follow the requirements and recommendations for
      data definitions given by <ref idref="ISO11179Part4"/>.</p>

    </rule>

    <figure>
      <title>Schematron supporting data definitions</title>
      <pre><xmlBlurb id="schematron-supporting-data-definitions" memberOf="ref ext">
<sch:pattern id="has-data-definition" abstract="true">
  <sch:rule context="$context">
    <sch:assert test="exists(xs:annotation/xs:documentation)">
      >$description MUST have a data definition.</sch:assert>
  </sch:rule>
  <sch:rule context="$context/xs:annotation/xs:documentation[
                       . is (../../xs:annotation/xs:documentation)[1]]">
    <sch:assert test="string-length(normalize-space(string(text()))) &gt; 0"
      >A data definition MUST NOT be empty. <sch:value-of select="count((../../xs:annotation/xs:documentation)[1])"/></sch:assert>
    <sch:assert test="empty(*)"
      >A data definition MUST NOT contain an element information item.</sch:assert>
  </sch:rule>
</sch:pattern>
      </xmlBlurb></pre>
    </figure>

    <rule applicability="REF EXT">
      <pre><xmlBlurb id="complex-type-defn-has-data-definition" memberOf="ref ext">
<sch:pattern is-a="has-data-definition" id="ct-has-data-defn">
  <sch:param name="context" value="xs:complexType[parent::xs:schema]"/>
  <sch:param name="description" value="A top-level complex type definition"/>
</sch:pattern>
      </xmlBlurb></pre>
    </rule>

    <rule applicability="REF EXT">
      <pre><xmlBlurb id="simple-type-defn-has-data-definition" memberOf="ref ext">
<sch:pattern is-a="has-data-definition">
  <sch:param name="context" value="xs:simpleType[parent::xs:schema]"/>
  <sch:param name="description" value="A top-level simple type definition"/>
</sch:pattern>
      </xmlBlurb></pre>
    </rule>

    <rule applicability="REF EXT">
      <pre><xmlBlurb id="element-decl-has-data-definition" memberOf="ref ext">
<sch:pattern is-a="has-data-definition">
  <sch:param name="context" value="xs:element[parent::xs:schema]"/>
  <sch:param name="description" value="A top-level element declaration"/>
</sch:pattern>
      </xmlBlurb></pre>
    </rule>

    <rule applicability="REF EXT">
      <pre><xmlBlurb id="attribute-decl-has-data-definition" memberOf="ref ext">
<sch:pattern is-a="has-data-definition">
  <sch:param name="context" value="xs:attribute[parent::xs:schema]"/>
  <sch:param name="description" value="A top-level attribute declaration"/>
</sch:pattern>
      </xmlBlurb></pre>
    </rule>

    <rule applicability="REF EXT">
      <pre><xmlBlurb id="enumeration-has-data-definition" memberOf="ref ext">
<sch:pattern is-a="has-data-definition">
  <sch:param name="context" value="xs:enumeration"/>
  <sch:param name="description" value="An enumeration"/>
</sch:pattern>
      </xmlBlurb></pre>
    </rule>

    <rule applicability="REF EXT">
      <pre><xmlBlurb id="schema-el-has-data-definition" memberOf="ref ext">
<sch:pattern is-a="has-data-definition">
  <sch:param name="context" value="xs:schema"/>
  <sch:param name="description" value="A {http://www.w3.org/2001/XMLSchema}schema element"/>
</sch:pattern>
      </xmlBlurb></pre>
    </rule>

  </section>

  <section>
    <title>No mixed content</title>
    <rule applicability="REF SUB EXT">
      <pre><xmlBlurb memberOf="ref sub ext" id="ct-no-mixed-content">
<sch:pattern>
  <sch:rule context="xs:complexType">
    <sch:assert test="empty(@mixed[xs:boolean(.) = true()])"
      >An element {http://www.w3.org/2001/XMLSchema}complexType SHALL NOT own the attribute "mixed" with the value true.</sch:assert>
  </sch:rule>
</sch:pattern>
      </xmlBlurb></pre>
    </rule>

    <rule applicability="REF SUB EXT">
      <pre><xmlBlurb memberOf="ref sub ext" id="complexcontent-no-mixed-content">
<sch:pattern>
  <sch:rule context="xs:complexContent">
    <sch:assert test="empty(@mixed[xs:boolean(.) = true()])"
      >An element {http://www.w3.org/2001/XMLSchema}complexContent SHALL NOT own the attribute "mixed" with the value true.</sch:assert>
  </sch:rule>
</sch:pattern>
      </xmlBlurb></pre>
    </rule>
  </section>
<!--
  <section>
    <title>No use of XML Schema notations</title>
    <p><ref idref="XMLSchemaStructures"/> makes it explicit that </p>
    <sch:rule applicability="REF SUB EXT">
      <pre><xmlBlurb memberOf="ref sub ext" id="no-ref-notation-type">
<sch:pattern>
  <sch:rule context="xs:extension/@base | xs:restriction/@base
                     | xs:">
    <sch:assert
      ></sch:assert>
  </sch:rule>
</sch:pattern>
      </xmlBlurb></pre>
    </sch:rule>

    <sch:rule applicability="REF EXT SUB">
      <p>The type xs:NOTATION MUST NOT be referenced</p>
    </sch:rule>
    <sch:rule applicability="SET">
      <p>A complex type MUST NOT be transitively derived from xs:notation</p>
    </sch:rule>

    <sch:rule applicability="SET">
      <p>A complex type may not be transitively derived from xs:notation</p>
    </sch:rule>
  </section>

-->

  <section>
    <title>Unsorted rules</title>

    <rule applicability="REF SUB EXT">
      <p>The schema SHALL NOT contain a reference to the type definition <code>xsd:NOTATION</code> or to a type derived from that type.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>The schema SHALL NOT contain the element <code>xsd:notation</code>.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>The schema SHALL NOT contain the element <code>xsd:include</code>.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>The schema SHALL NOT contain the element <code>xsd:redefine</code>.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>The schema SHALL NOT reference the type <code>xsd:anyType</code>.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>The schema SHALL NOT reference the type <code>xsd:anySimpleType</code>.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>Within the schema, an element declaration with the attribute <code>name</code> and without the attribute <code>type</code> MUST carry the attribute <code>abstract</code> with the value <code>true</code>.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>Within the schema, an attribute declaration with attribute <code>name</code> MUST carry the attribute <code>type</code>.</p>
    </rule>
    <rule applicability="REF SUB">
      <p>The schema SHALL NOT contain the element <code>xsd:any</code>.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>The schema SHALL NOT contain the element <code>xsd:anyAttribute</code>.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>Within the schema, any occurrence of the element <code>xsd:complexType</code> or <code>xsd:simpleType</code> MUST appear as an immediate child of the element <code>xsd:schema</code>.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>Within the schema, any element declaration carrying the attribute <code>name</code> MUST appear as an immediate child of the document element <code>xsd:schema</code>.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>Within the schema, any attribute declaration owning the attribute <code>name</code> MUST appear as an immediate child of the document element <code>xsd:schema</code>.</p>
    </rule>
    <rule applicability="REF EXT">
      <p>The schema SHALL NOT contain any of the elements <code>xsd:unique</code>, <code>xsd:key</code>, <code>xsd:keyref</code>, <code>xsd:selector</code>, or <code>xsd:field</code>.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>The schema SHALL NOT contain the element <code>xsd:all</code>.</p>
    </rule>
    <rule applicability="REF">
      <p>The schema SHALL NOT contain the element <code>xsd:choice</code>.</p>
    </rule>
    <rule applicability="REF SUB">
      <p>Within the schema, any immediate child of a model group <code>xsd:sequence</code> element MUST be one of <code>xsd:annotation</code> or <code>xsd:element</code>.</p>
    </rule>
    <rule applicability="EXT">
      <p>Within the schema, any immediate child of a model group <code>xsd:sequence</code> element MUST be one of <code>xsd:annotation</code>, <code>xsd:element</code>, <code>xsd:choice</code>, or <code>xsd:any</code>.</p>
    </rule>
    <rule applicability="EXT">
      <p>Within the schema, any immediate child of a model group <code>xsd:choice</code> element MUST be one of <code>xsd:annotation</code> or <code>xsd:element</code>.</p>
    </rule>
    <rule applicability="EXT">
      <p>The use of <code>xsd:choice</code> SHALL define syntax, structure, grouping, and cardinality of instances, but SHALL NOT define semantics. The semantics of a property within an <code>xsd:choice</code> SHALL be identical to the semantics of the property within an <code>xsd:sequence</code>.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>The schema SHALL NOT contain the element <code>xsd:group</code>.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>Within the schema, if the element <code>xsd:sequence</code> carries the attribute <code>minOccurs</code>, it MUST set the value for the attribute to <code>1</code>.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>Within the schema, if the element <code>xsd:sequence</code> carries the attribute <code>maxOccurs</code>, it MUST set the value of the attribute to <code>1</code>.</p>
    </rule>
    <rule applicability="REF EXT">
      <p>Within the schema, if an element declaration carries the attribute <code>block</code>, it MUST set the value for the attribute to the empty string.</p>
    </rule>
    <rule applicability="REF EXT">
      <p>Within the schema, if a complex type definition carries the attribute <code>block</code>, it MUST set the value for the attribute to the empty string.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>Within the schema, if the document element <code>xsd:schema</code> carries the attribute <code>blockDefault</code>, it MUST set the value for the attribute to the empty string.</p>
    </rule>
    <rule applicability="REF SUB">
      <p>Within the schema, if a simple type definition carries the attribute <code>final</code>, it MUST set the value for the attribute to the empty string.</p>
    </rule>
    <rule applicability="REF SUB">
      <p>Within the schema, if a complex type definition carries the attribute <code>final</code>, it MUST set the value for the attribute to the empty string.</p>
    </rule>
    <rule applicability="REF SUB">
      <p>Within the schema, if an element declaration carries the attribute <code>final</code>, it MUST set the value for the attribute to the empty string.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>Within the schema, if the document element <code>xsd:schema</code> carries the attribute <code>finalDefault</code>, it MUST set the value for that attribute to the empty string.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>Within the schema, any element <code>xsd:element</code> SHALL NOT carry the attribute <code>default</code>.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>Within the schema, any element <code>xsd:attribute</code> SHALL NOT carry the attribute <code>default</code>.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>Within the schema, the document element <code>xsd:schema</code> MUST carry the attribute <code>targetNamespace</code>.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>Within the schema, the value of the required attribute <code>targetNamespace</code> on the document element <code>xsd:schema</code> MUST match the production <code>&lt;absolute-URI&gt;</code> as defined by <ref idref="RFC3986"/>.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>Within the schema, the document element <code>xsd:schema</code> MUST carry the attribute <code>version</code>.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>Within the schema, the value of the required attribute <code>version</code> on the document element <code>xsd:schema</code> MUST NOT be an empty string.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>Within the schema, the element <code>xsd:import</code> MUST carry the attribute <code>namespace</code>.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>Within the schema, the value of the required attribute <code>namespace</code> owned by the element <code>xsd:import</code> MUST match the production <code>&lt;absolute-URI&gt;</code> as defined by <ref idref="RFC3986"/>.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>Within the schema, the element <code>xsd:import</code> MUST carry the attribute <code>schemaLocation</code>.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>Within the schema, the value of the required attribute <code>schemaLocation</code> carried by the element <code>xsd:import</code> MUST match either the production <code>&lt;absolute-URI&gt;</code> or the definition of <q>
          <em>relative-path reference</em>,</q> as defined by <ref idref="RFC3986"/>.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>Within the schema, the value of the required attribute <code>schemaLocation</code> carried by the element <code>xsd:import</code> MUST be resolvable to a XML schema document file that is valid according to <ref idref="XMLSchemaStructures"/> and <ref idref="XMLSchemaDatatypes"/>.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>Within the schema, when a namespace other than the XML namespace or the XML Schema namespace is used, it MUST be imported into the schema using the <code>xsd:import</code> element.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>Within the schema, when a namespace other than the XML namespace or the XML Schema namespace is used, its content MUST be valid with respect to the schema imported for that namespace.</p>
    </rule>
    <rule applicability="REF EXT">
      <p>Within the schema, an element SHALL have at most one instance of an element <code>xsd:annotation</code> as an immediate child.</p>
    </rule>
    <rule applicability="REF EXT">
      <p>Within theschema, the content of the <code>xsd:documentation</code> element that constitutes the data definition of a component MUST be character information items as specified by <ref idref="XMLInfoSet"/>.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>XML comments SHALL not be used for persistent information about constructs within the schema.</p>
    </rule>
    <rule applicability="REF EXT">
      <p>Within the schema, any immediate child of an <code>xsd:appinfo</code> element SHALL be an element information item or a comment information item.</p>
    </rule>
    <rule applicability="REF EXT">
      <p>Within the schema, any element that is an immediate child of an <code>xsd:appinfo</code> element SHALL be in a namespace.</p>
    </rule>
    <rule applicability="REF EXT">
      <p>Within the schema, an element in the XML Schema namespace MUST NOT occur as a descendant of any element <code>xsd:appinfo</code>.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>Within the schema, the element <code>xsd:complexType</code> MUST have as an immediate child either the element <code>xsd:complexContent</code> or the element <code>xsd:simpleContent</code>.</p>
    </rule>
    <rule applicability="REF">
      <p>Within the schema, the element <code>xsd:simpleContent</code> MUST have as an immediate child the element <code>xsd:extension</code>.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>Within the schema, given an element <code>xsd:simpleContent</code> with a child <code>xsd:extension</code> owning an attribute <code>base</code>, if the attribute <code>base</code> has a value that resolves to the name of a simple type, then the element <code>xsd:extension</code> MUST have an immediate child element <code>xsd:attributeGroup</code>.</p>
    </rule>
    <rule applicability="REF">
      <p>Within the schema, the element <code>xsd:complexContent</code> MUST have as an immediate child the element <code>xsd:extension</code>.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>Within the schema, given an element <code>xsd:complexContent</code> with a child <code>xsd:extension</code> owning an attribute <code>base</code>, the attribute <code>base</code> MUST have a value that resolves to the name of one of the following:</p>
      <ol>
        <li>
          <p>The type <code>structures:ComplexObjectType</code>.</p>
        </li>
        <li>
          <p>The type <code>structures:MetadataType</code>.</p>
        </li>
        <li>
          <p>The type <code>structures:AugmentationType</code>.</p>
        </li>
        <li>
          <p>A complex type that is a NIEM-conformant component.</p>
        </li>
      </ol>
    </rule>
    <rule applicability="EXT">
      <p>Within the schema, given an element <code>xsd:complexContent</code> with a child <code>xsd:restriction</code> owning an attribute <code>base</code>, the attribute <code>base</code> MUST have a value that resolves to the name of a complex type that is a NIEM-conformant component.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>Within the schema, any occurrence of the element <code>xsd:attributeGroup</code> MUST own an attribute <code>ref</code>.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>Within the schema, the attribute <code>ref</code> owned by any element <code>xsd:attributeGroup</code> MUST have a value of a qualified name (possibly using the default namespace) that SHALL resolve to the namespace for the NIEM <code>structures</code> namespace and the local name <code>SimpleObjectAttributeGroup</code>.</p>
    </rule>
    <rule applicability="REF EXT">
      <p>Within the schema, the document element <code>xsd:schema</code> MUST have application information <code>appinfo:ConformantIndicator</code>, with text content <code>
          <q>true</q>
        </code>.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>Two XML Schema documents SHALL have the same value for attribute <code>targetNamespace</code> carried by the element <code>xsd:schema</code>, if and only if they represent the same set of components.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>Two XML Schema documents SHALL have the same value for attribute <code>targetNamespace</code> carried by the element <code>xsd:schema</code>, and different values for attribute <code>version</code> carried by the element <code>xsd:schema</code> if and only if they are different views of the same set of components.</p>
    </rule>
    <rule applicability="REF EXT">
      <p>Words or synonyms for the words within a data element definition SHALL NOT be reused as terms in the corresponding component name if those words dilute the semantics and understanding of, or impart ambiguity to, the entity or concept that the component represents.</p>
    </rule>
    <rule applicability="REF EXT">
      <p>An object class SHALL have one and only one associated semantic meaning (i.e., a single word sense) as described in the definition of the component that represents that object class.</p>
    </rule>
    <rule applicability="REF EXT">
      <p>An object class SHALL NOT be redefined within the definitions of the components that represent properties or subparts of that entity or class.</p>
    </rule>
    <rule applicability="REF EXT">
      <p>A data definition SHALL NOT contain explicit representational or data typing information such as number characters, type of characters, etc., unless the very nature of the component can be described only by such information.</p>
    </rule>
    <rule applicability="REF EXT">
      <p>A component definition SHALL begin with a standard opening phrase that depends on the class of the component per Table 7-1: Standard Opening Phrases:</p>
    </rule>
    <definition term="appinfo namespace">
      <p>The <strong>appinfo namespace</strong> is the namespace represented by the URI <em>
          <q>http://niem.gov/niem/appinfo/2.0</q>
        </em>.</p>
    </definition>
    <rule applicability="REF EXT">
      <p>The schema SHALL import the <code>appinfo</code> namespace.</p>
    </rule>
    <definition term="application information">
      <p>A component is said to have <strong>application information</strong> of some element E when the root element that defines the component has an immediate child element <code>xsd:annotation</code>, which has an immediate child element <code>xsd:appinfo</code>, which has as an immediate child the element <strong>E</strong>.</p>
    </definition>
    <definition term="deprecated component">
      <p>In a particular NIEM-conformant namespace, a <strong>deprecated component</strong> is one whose use is not recommended, yet which is maintained in the schema for compatibility with previous versions of the namespace.</p>
    </definition>
    <rule applicability="REF EXT">
      <p>A component that is deprecated SHALL be indicated as such by the component having application information <code>appinfo:Deprecated</code>, with an attribute <code>value</code> with a value of <code>true</code>.</p>
    </rule>
    <rule applicability="REF EXT">
      <p>Within the schema, the element <code>appinfo:Base</code> MAY be used in one of the following ways:</p>
      <ol>
        <li>
          <p>By a type definition, to indicate the base type, or <code>structures:Object</code> or <code>structures:Association</code>.</p>
        </li>
        <li>
          <p>By an element declaration, to indicate the base element.</p>
        </li>
      </ol>
      <p>The element <code>appinfo:Base</code> SHALL NOT be used for any other purpose.</p>
    </rule>
    <rule applicability="REF EXT">
      <p>Within the schema, the element <code>appinfo:Base</code> SHALL indicate, by namespace and name, one of the following:</p>
      <ol>
        <li>
          <p>A NIEM-conformant schema component.</p>
        </li>
        <li>
          <p>
            <code>structures:Object</code>.</p>
        </li>
        <li>
          <p>
            <code>structures:Association</code>.</p>
        </li>
      </ol>
    </rule>
    <rule applicability="REF EXT">
      <p>Within the schema, an attribute <code>appinfo:namespace</code> owned by an element <code>appinfo:Base</code> SHALL have a value of either of the following:</p>
      <ol>
        <li>
          <p>A namespace which is the target namespace of a NIEM-conformant schema.</p>
        </li>
        <li>
          <p>The <code>structures</code> namespace.</p>
        </li>              
      </ol>
    </rule>
    <rule applicability="REF EXT">
      <p>Within the schema, an element <code>appinfo:Base</code> that does not own an attribute <code>appinfo:namespace</code> SHALL refer to the target namespace of the schema in which it is used.</p>
    </rule>
    <rule applicability="REF EXT">
      <p>Within the schema, an element <code>appinfo:Base</code> SHALL own an attribute <code>appinfo:name</code>.</p>
    </rule>
    <rule applicability="REF EXT">
      <p>Within the schema, if an element <code>appinfo:Base</code> indicates a NIEM-conformant namespace, then the value of the attribute <code>appinfo:name</code> owned by the element <code>appinfo:Base</code> SHALL indicate a schema component in the indicated namespace.</p>
    </rule>
    <rule applicability="REF EXT">
      <p>Within the schema, if an element <code>appinfo:Base</code> indicates the <code>structures</code> namespace, then the value of the attribute <code>appinfo:name</code> owned by the element <code>appinfo:Base</code> SHALL have a value of one of the following:</p>
      <ol>
        <li>
          <p>
            <code>structures:Object</code>.</p>
        </li>
        <li>
          <p>
            <code>structures:Association</code>.</p>
        </li>
        <li>
          <p>A schema component defined by the <code>structures</code> schema.</p>
        </li>
      </ol>
    </rule>
    <rule applicability="REF EXT">
      <p>Within the schema, the element <code>appinfo:AppliesTo</code> MAY be used in any of the following ways:</p>
      <ol>
        <li>
          <p>To indicate a base type to which an augmentation may be applied.</p>
        </li>
        <li>
          <p>To indicate a base type to which a metadata type may be applied.</p>
        </li>
      </ol>
      <p>The element <code>appinfo:AppliesTo</code> SHALL NOT be used for any other purpose.</p>
    </rule>
    <rule applicability="REF EXT">
      <p>Within the schema, the element <code>appinfo:AppliesTo</code> SHALL indicate a schema component by namespace and name.</p>
    </rule>
    <rule applicability="REF EXT">
      <p>Within the schema, an attribute <code>appinfo:namespace</code> owned by an element <code>appinfo:AppliesTo</code> SHALL indicate the namespace of the type to which <code>appinfo:AppliesTo</code> refers. The indicated namespace SHALL be defined by a NIEM-conformant schema.</p>
    </rule>
    <rule applicability="REF EXT">
      <p>Given that the element <code>appinfo:AppliesTo</code> refers to a type, the applicability described by the element SHALL be understood to be the indicated type or a type transitively derived from the indicated type.</p>
    </rule>
    <rule applicability="REF EXT">
      <p>Within the schema, an element <code>appinfo:AppliesTo</code> that does not carry an attribute <code>appinfo:namespace</code> SHALL refer to the target namespace of the schema in which it is used.</p>
    </rule>
    <rule applicability="REF EXT">
      <p>Within the schema, an element <code>appinfo:AppliesTo</code> SHALL carry an attribute <code>appinfo:name</code>. The value of this attribute SHALL indicate the local name of a schema component within the namespace specified by the element.</p>
    </rule>
    <rule applicability="REF EXT">
      <p>Within the schema, the element <code>appinfo:ReferenceTarget</code> SHALL identify the XML Schema type definition of an element information item to which an instance of a reference element may validly refer. The element <code>appinfo:ReferenceTarget</code> SHALL NOT be used for any other purpose.</p>
    </rule>
    <rule applicability="REF EXT">
      <p>Within the schema, a reference element MUST have at most one instance of the element <code>appinfo:ReferenceTarget</code>.</p>
    </rule>
    <rule applicability="REF EXT">
      <p>Within the schema, the element <code>appinfo:ReferenceTarget</code> SHALL indicate a type definition schema component, by namespace and name.</p>
    </rule>
    <rule applicability="REF EXT">
      <p>Within the schema, an attribute <code>appinfo:namespace</code> carried by an element <code>appinfo:ReferenceTarget</code> SHALL indicate the namespace of the referenced schema component. The indicated namespace SHALL be defined by a reference or extension schema.</p>
    </rule>
    <rule applicability="REF EXT">
      <p>Within the schema, an element <code>appinfo:ReferenceTarget</code> that does not carry an attribute <code>appinfo:namespace</code> SHALL refer to the target namespace of the schema in which it is used.</p>
    </rule>
    <rule applicability="REF EXT">
      <p>Within the schema, an element <code>appinfo:ReferenceTarget</code> SHALL carry an attribute <code>appinfo:name</code>. The value of this attribute SHALL indicate the local name of a type definition schema component within the namespace specified by the element.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>Within the schema, a simple type definition that uses <code>xsd:list</code> SHOULD NOT be defined if any member of the list requires a property or metadata that is different than other members of the list. All members of the list SHOULD have the same metadata, and should be related via the same properties.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>Within the schema, a complex type definition SHALL be one of the following classes of types:</p>
      <ol>
        <li>
          <p>An object type.</p>
        </li>
        <li>
          <p>A role type.</p>
        </li>
        <li>
          <p>An association type.</p>
        </li>
        <li>
          <p>A metadata type.</p>
        </li>
        <li>
          <p>An augmentation type.</p>
        </li>
        <li>
          <p>An adapter type.</p>
        </li>
      </ol>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>Within the schema, an element MUST NOT be introduced more than once into the direct content of a type definition. This applies to content acquired through extension of base types. This does not apply to a base element or derived element to one previously existing in the type definition.</p>
    </rule>
    <definition term="object type">
      <p>In a NIEM-conformant schema, an <strong>object type</strong> is a complex type definition, an instance of which asserts the existence of an object. An object type represents some kind of object: a thing with its own lifespan that has some existence. The object may or may not be a physical object. It may be a conceptual object.</p>
    </definition>
    <rule applicability="REF EXT">
      <p>Within the schema, an object type SHALL be a complex type definition that either constitutes a NIEM-conformant component or for which there exists a NIEM-conformant component of one of the following forms:</p>
      <ol>
        <li>
          <p>Has simple content, is based on a simple type, and contains the attribute group <code>structures:SimpleObjectAttributeGroup</code>, and has application information <code>appinfo:Base</code> of <code>structures:Object</code>.</p>
        </li>
        <li>
          <p>Has complex content, and is based on complex type <code>structures:ComplexObjectType</code>, and has application information <code>appinfo:Base</code> of <code>structures:Object</code>.</p>
        </li>
        <li>
          <p>Is a complex type that is derived from an object type, which is defined according to this rule.</p>
        </li>
      </ol>
    </rule>
    <definition term="role type">
      <p>A <strong>role type</strong> is a type that represents a particular function, purpose, usage, or role of an object.</p>
    </definition>
    <definition term="RoleOf element">
      <p>In a NIEM-conformant schema, a <code>RoleOf</code> 
        <strong>element</strong> is a reference element whose type is the base type of the role.</p>
    </definition>
    <rule applicability="REF SUB EXT">
      <p>Within the schema, any element with a name beginning with the string <code>RoleOf</code> SHALL represent a base type, of which the containing type represents a role.</p>
    </rule>
    <definition term="association type">
      <p>In a NIEM-conformant schema, an <strong>association type</strong> is a type that establishes a relationship between objects, along with the properties of that relationship. An association type provides a structure that does not establish existence of an object but instead specifies relationships between objects.</p>
    </definition>
    <definition term="association">
      <p>In a NIEM-conformant schema, an <strong>association</strong> is an element whose type is an association type.</p>
    </definition>
    <rule applicability="REF EXT">
      <p>Within the schema, an association type SHALL be a complex type definition that either constitutes a NIEM-conformant component or for which there exists a NIEM-conformant component definition. The NIEM-conformant component definition SHALL have one of the following forms:</p>
      <ol>
        <li>
          <p>Has complex content, is based on the complex type <code>structures:ComplexObjectType</code>, and has application information <code>appinfo:Base</code> of <code>structures:Association</code>.</p>
        </li>
        <li>
          <p>Is a complex type that is derived from an association type, which is defined according to this rule.</p>
        </li>
      </ol>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>Given that an association type defines a relationship between a set of participants, within an association type definition, any element that represents a participant SHALL be a reference element.</p>
    </rule>
    <definition term="metadata type">
      <p>A <strong>metadata type</strong> describes data about data, that is, information that is not descriptive of objects and their relationships, but is descriptive of the data itself. It is useful to provide a general mechanism for data about data. This provides required flexibility to precisely represent information.</p>
    </definition>
    <definition term="metadata element">
      <p>Within a NIEM-conformant schema, a <strong>metadata element</strong> is an element whose type is a metadata type. There are specific limitations on the meaning of a metadata element in an instance; it does not establish existence of an object, nor is it a property of its containing object.</p>
    </definition>
    <rule applicability="REF SUB EXT">
      <p>Within the schema, a metadata type SHALL contain elements appropriate for a specific class of data about data.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>Within the schema, a metadata type and only a metadata type SHALL be derived directly from <code>structures:MetadataType</code>.</p>
    </rule>
    <rule applicability="REF EXT">
      <p>Within the schema, a metadata type MAY have application information <code>appinfo:AppliesTo</code>, indicating the NIEM-conformant object, association, or external adapter types to which the metadata applies.</p>
    </rule>
    <rule applicability="REF EXT">
      <p>Within the schema, a metadata type that does not have application information <code>appinfo:AppliesTo</code> MAY be applied to any object type, association type, or external adapter type.</p>
    </rule>
    <definition term="augmentation type">
      <p>An <strong>augmentation type</strong> is a complex type that provides a reusable block of data that may
        be added to object types or association types.</p>
    </definition>
    <definition term="augmentation">
      <p>An <strong>augmentation</strong> of a NIEM-conformant object type is a block of additional data added
        to an object type to carry additional data beyond that of the original object definition.</p>
    </definition>
    <rule applicability="REF SUB EXT">
      <p>An augmentation type:</p>
      <ol>
        <li>
          <p>SHALL be transitively derived from <code>structures:AugmentationType</code>.</p>
        </li>
        <li>
          <p>SHALL contain elements that represent properties to be applied to a base type.</p>
        </li>
      </ol>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>Within the schema, an augmentation element definition:</p>
      <ol>
        <li>
          <p>SHALL have a type that is an augmentation type.</p>
        </li>
        <li>
          <p>SHALL use the <code>substitutionGroup</code> attribute such that it is transitively substitutable for the element <code>structures:Augmentation</code>.</p>
        </li>
      </ol>
      <p>An element that is not an augmentation element SHALL NOT meet either of the above criteria.</p>
    </rule>
    <rule applicability="REF EXT">
      <p>Within the schema, an element definition for an augmentation element MAY contain one or more instances of the element <code>structures:AppliesTo</code> as application information to specify types to which the augmentation element applies.</p>
    </rule>
    <rule applicability="REF EXT">
      <p>Within the schema, an element definition for an augmentation element that does not contain any instances of the element <code>structures:AppliesTo</code> MAY be applied to any object or association type.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>Any type definition referenced by a component within the schema MUST be from one of the following:</p>
      <ol>
        <li>
          <p>The schema being defined.</p>
        </li>
        <li>
          <p>A namespace imported as NIEM-conformant.</p>
        </li>
        <li>
          <p>The XML Schema namespace.</p>
        </li>
        <li>
          <p>The <code>structures</code> namespace.</p>
        </li>
      </ol>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>Any element declaration referenced by a component within the schema MUST be from one of the following:</p>
      <ol>
        <li>
          <p>The schema being defined.</p>
        </li>
        <li>
          <p>A namespace imported as NIEM-conformant.</p>
        </li>
        <li>
          <p>The <code>structures</code> namespace.</p>
        </li>
        <li>
          <p>An external namespace, in accordance with the rules for external schemas as specified by this specification.</p>
        </li>
      </ol>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>Any attribute declaration referenced by a component within the schema MUST be from one of the following:</p>
      <ol>
        <li>
          <p>The schema being defined.</p>
        </li>
        <li>
          <p>A namespace imported as NIEM-conformant.</p>
        </li>
        <li>
          <p>The <code>structures</code> namespace.</p>
        </li>
        <li>
          <p>The XML namespace.</p>
        </li>
        <li>
          <p>An external namespace, in accordance with the rules for external schemas as specified by this specification.</p>
        </li>
      </ol>
    </rule>
    <definition term="structures namespace">
      <p>The <strong>structures namespace</strong> is the namespace represented by the URI <code>
          <q>http://niem.gov/niem/structures/2.0</q>
        </code>.</p>
    </definition>
    <rule applicability="REF EXT">
      <p>The schema MUST import the NIEM <code>structures</code> namespace.</p>
    </rule>
    <rule applicability="REF SUB EXT INS">
      <p>The schema or instance MUST use content within the NIEM <code>structures</code> namespace as specified in this document and ONLY as specified by this document.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>Within the schema, a complex type definition SHALL include the attribute <code>structures:sequenceID</code> if the order of an occurrence of the type, within its parent, relative to its siblings, is meaningful and pertinent and if the schema does not specify the desired sequential order.</p>
    </rule>
    <definition term="reference element">
      <p>A <strong>reference element</strong> is an element that refers to its value by a reference attribute instead of carrying it as content.</p>
    </definition>
    <rule applicability="REF SUB EXT">
      <p>Within the schema, a reference element and only a reference element SHALL be defined to be of type <code>structures:ReferenceType</code>.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>Within the schema, a complex type SHALL NOT be defined such that an instance of that type owns the attribute <code>structures:ref</code>.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>Within the schema, any two elements of the form</p>
      <p>
        <em>NCName</em>
      </p>
      <p>and</p>
      <p>
        <code>
          <em>NCName</em>Reference</code>
      </p>
      <p>where the string value of <em>NCName</em> is the same in both forms, SHALL be defined to have identical semantics. NIEM recognizes no difference in meaning between a reference element and an element that is not a reference element.</p>
    </rule>
    <rule applicability="REF EXT">
      <p>Within the schema, if both elements <em>NCName</em> and <code>
          <em>NCName</em>Reference</code> exist, then the <code>appinfo:ReferenceTarget</code> of any <code>
          <em>NCName</em>Reference</code> element MUST be the type of the element <em>NCName</em>.</p>
    </rule>
    <definition term="external schema">
      <p>An <strong>external schema</strong> is any schema that is not a supporting schema and that is not NIEM-conformant.</p>
    </definition>
    <rule applicability="REF EXT">
      <p>Within the schema, an element <code>xsd:import</code> that imports a namespace defined by an external schema MUST have the application information <code>appinfo:ConformantIndicator</code>, with a value of <code>false</code>.</p>
    </rule>
    <rule applicability="REF EXT">
      <p>Within the schema, an element <code>xsd:import</code> that imports a namespace defined by an external schema MUST be a documented component.</p>
    </rule>
    <definition term="adapter type">
      <p>An <strong>adapter type</strong> is a NIEM-conformant type that adapts external components for use within NIEM. An adapter type creates a new class of object that embodies a single concept composed of external components. A NIEM-conformant schema defines an adapter type.</p>
    </definition>
    <rule applicability="REF EXT">
      <p>Within the schema, an adapter type MUST have application information <code>appinfo:ExternalAdapterTypeIndicator</code> with a value of <code>true</code>. A type that is not an adapter type SHALL NOT contain that indicator.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>Within the schema, an adapter type MUST be an immediate extension of type <code>structures:ComplexObjectType</code>.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>Within the schema, an adapter type MUST be composed of only elements and attributes from an external standard.</p>
    </rule>
    <rule applicability="REF EXT">
      <p>Within the schema, an element reference used in an adapter type definition MUST be a documented component.</p>
    </rule>
    <rule applicability="REF EXT">
      <p>Within the schema, an attribute reference used in an adapter type definition MUST be a documented component.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>Within the schema, an adapter type MUST NOT be extended or restricted.</p>
    </rule>
    <rule applicability="SUB">
      <p>The value of the <code>targetNamespace</code> attribute owned by the <code>xsd:schema</code> document element of the subset schema must be the same as the value of the <code>targetNamespace</code> attribute owned by the <code>xsd:schema</code> document element of the reference schema.</p>
    </rule>
    <rule applicability="SUB">
      <p>The schema must be constructed such that any instance that is XML Schema valid against the schema must also be XML Schema valid against the base schema.</p>
    </rule>
    <rule applicability="INS">
      <p>The XML document MUST be schema-valid, assessed with reference to the schema composed of the reference schemas, extension schemas, exchange schemas, utility schemas, and external schemas for the relevant namespaces.</p>
    </rule>
    <rule applicability="INS">
      <p>Within the instance, the meaning of an element with no content is that additional properties are not asserted. There SHALL NOT be additional meaning interpreted for an element with no content.</p>
    </rule>
    <rule applicability="INS">
      <p>Within an element instance, there SHALL NOT be any difference in meaning between a property asserted via element containment and a property asserted by element reference, except as explicitly described by the semantics of the elements involved.</p>
    </rule>
    <rule applicability="INS">
      <p>Given that the IDREF that is the value of an attribute <code>structures:ref</code> matches the value of an ID attribute on some element in the XML document, that ID attribute must be an occurrence of the attribute <code>structures:id</code>.</p>
    </rule>
    <rule applicability="INS">
      <p>Within an element instance, given that a reference element is restricted to a target type T, any attribute <code>structures:ref</code> MUST reference an element that has a type definition of type T or that is derived from type T.</p>
    </rule>
    <rule applicability="INS">
      <p>The order of elements that are children of an element SHALL be presented as if their sequential order is as follows:</p>
      <ol>
        <li>
          <p>First, elements owning an attribute <code>structures:sequenceID</code>, in the order that would be yielded with their sequence IDs sorted via <code>sort</code> element as defined by <ref idref="XSLT"/>, with a data type of <code>number</code> and an order of <code>ascending</code>.</p>
        </li>
        <li>
          <p>Following those elements, the remaining elements, in the order in which they occur within the XML instance.</p>
        </li>
      </ol>
    </rule>
    <rule applicability="REF EXT INS">
      <p>Within a schema or instance, the attribute <code>structures:sequenceID</code> SHALL NOT be interpreted as meaningful beyond an indicator of sequential order of an object relative to its siblings.</p>
    </rule>
    <rule applicability="INS">
      <p>Within an element instance, when an object O links to a metadata object via an attribute <code>structures:metadata</code>, the information in the metadata object SHALL be applied to the object O.</p>
    </rule>
    <rule applicability="INS">
      <p>Within an element instance, when an object O1 contains an element E, with content object O2 or with a reference to object O2, and O2 links to a metadata object via an attribute <code>structures:linkMetadata</code>, the information in the metadata object SHALL be applied to the relationship E between O1 and O2.</p>
    </rule>
    <rule applicability="INS">
      <p>Given that each IDREF in the value of an attribute <code>structures:metadata</code> must match the value of an ID attribute on some element in the XML document, that ID attribute MUST be an occurrence of the attribute <code>structures:id</code>.</p>
    </rule>
    <rule applicability="INS">
      <p>Each element that an attribute <code>structures:metadata</code> references MUST have a type definition that is derived from <code>structures:MetadataType</code>.</p>
    </rule>
    <rule applicability="INS">
      <p>Given that each IDREF in the value of an attribute <code>structures:linkMetadata</code> must match the value of an ID attribute on some element in the XML document, that ID attribute MUST be an occurrence of the attribute <code>structures:id</code>.</p>
    </rule>
    <rule applicability="INS">
      <p>Each element that an attribute <code>structures:linkMetadata</code> references MUST have a type definition that is derived from structures:MetadataType.</p>
    </rule>
    <rule applicability="INS">
      <p>Given that an element information item E has a type definition of some type T, each metadata type that is the type definition of an element information item referenced by an attribute <code>structures:metadata</code> or <code>structures:linkMetadata</code> on element E MUST be applicable to T.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>Within the schema, a complex type that is a direct extension of a simple type from the XML Schema namespace simple type MAY use the same local name as the simple type if and only if the extension adds no content other than the attribute group <code>structures:SimpleObjectAttributeGroup</code>.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>The name of any XML Schema component defined by the schema SHALL be composed of words from the English language, using the prevalent U.S. spelling, as provided by <ref idref="OED"/>.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>The name of any XML Schema component defined by the schema SHALL contain only the following characters:</p>
      <ul>
        <li>
          <p>Upper-case letters ('<code>A</code>'-'<code>Z</code>').</p>
        </li>
        <li>
          <p>Lower-case letters ('<code>a</code>'-'<code>z</code>').</p>
        </li>
        <li>
          <p>Digits ('<code>0</code>'-'<code>9</code>').</p>
        </li>
        <li>
          <p>Hyphen ('<code>-</code>').</p>
        </li>
      </ul>
      <p>Other characters, such as the underscore (<q>
          <code>_</code>
        </q>) character and the period (<q>
          <code>.</code>
        </q>) character SHALL NOT appear in component names in NIEM-conformant schemas.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>The hyphen character (<q>-</q>) MAY appear in component names only when used as a separator between parts of a single word, phrase, or value, which would otherwise be incomprehensible without the use of a separator.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>Within the schema, any attribute declaration SHALL have a name that begins with a lower-case letter ('<code>a</code>'-'<code>z</code>').</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>Within the schema, any XML Schema component other than an attribute declaration SHALL have a name that begins with an upper-case letter ('<code>A</code>'-'<code>Z</code>').</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>The name of any XML Schema component defined by the schema SHALL use the camel case formatting convention.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>The schema MUST consistently use approved acronyms, abbreviations, and word truncations within defined names. The approved shortened forms are defined in Table 9-1: Abbreviations Used in NIEM Core Names.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>A noun used as a term in the name of an XML Schema component MUST be in singular form unless the concept itself is plural.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>A verb used as a term in the name of an XML Schema component MUST be used in the present tense unless the concept itself is past tense.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>Articles, conjunctions, and prepositions SHALL NOT be used in NIEM component names except where they are required for clarity or by standard convention.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>Except as specified elsewhere in this document, any element or attribute defined within the schema SHALL have a name that takes the form:</p>
      <ul>
        <li>
          <p>Object-class qualifier terms (0 or more).</p>
        </li>
        <li>
          <p>An object class term (1).</p>
        </li>
        <li>
          <p>Property qualifier terms (0 or more).</p>
        </li>
        <li>
          <p>A property term (1).</p>
        </li>
        <li>
          <p>Representation qualifier terms (0 or more).</p>
        </li>
        <li>
          <p>A representation term (1).</p>
        </li>
      </ul>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>The object-class term of a NIEM component SHALL consist of a term identifying a category of concrete concepts or entities.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>A property term SHALL describe or represent a characteristic or subpart of an entity or concept.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>Multiple qualifier terms MAY be used within a component name as necessary to ensure clarity and uniqueness within its namespace and usage context.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>The number of qualifier terms SHOULD be limited to the absolute minimum required to make the component name unique and understandable.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>The order of qualifiers SHALL NOT be used to differentiate names.</p>
    </rule>
    <rule applicability="REF EXT">
      <p>If any word in the representation term is redundant with any word in the property term, one occurrence SHOULD be deleted.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>Within the schema, the name of an element declaration that is of simple content MUST use a representation term found in Table 9-2: Representation Terms.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>Within the schema, the name of an element declaration that is of complex content, and that corresponds to a concept listed in Table 9-2: Representation Terms, MUST use a representation term from that table.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>Within the schema, the name of an element declaration that is of complex content and that does not correspond to a concept listed in Table 9-2: Representation Terms MUST NOT use a representation term.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>Within the schema, the name of an attribute declaration MUST use a representation term from Table 9-2: Representation Terms.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>Within the schema, the name of any type definition MUST use the representation term <code>Type</code>.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>Within the schema, the name of any simple type definition SHALL use the representation term qualifier <code>Simple</code>. This qualifier SHALL appear after any other representation term qualifiers.</p>
    </rule>
    <definition term="code type">
      <p>A <strong>code type</strong> is a simple type schema component definition that contains multiple <code>xsd:enumeration</code> facets.</p>
    </definition>
    <rule applicability="REF SUB EXT">
      <p>Within the schema, the name of any code type SHALL use the representation term qualifier <code>Code</code>.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>Within the schema, any type definition which has a base type definition of a code type or which is transitively based on a code type SHALL have a name that uses the representation term qualifier <code>Code</code>.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>Within the schema, any association type SHALL have a name that uses the representation term qualifier <code>Association</code>. Types other than association types SHALL NOT use the representation term qualifier <code>Association</code>.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>Within the schema, any augmentation type SHALL have a name that uses the representation term qualifier <code>Augmentation</code>. Types other than augmentation types SHALL NOT use the representation term qualifier <code>Augmentation</code>.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>Within the schema, any metadata type SHALL have a name that uses the representation term qualifier <code>Metadata</code>. Types other than metadata types SHALL NOT use the representation term qualifier <code>Metadata</code>.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>Within the schema, the name of any attribute group definition schema component SHALL use the representation term <code>AttributeGroup</code>.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>Within the schema, the name of any reference element SHALL use the representation term suffix <code>Reference</code>.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>Within the schema, the name of an association element SHALL use the representation term qualifier <code>Association</code>.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>Within the schema, the name of an augmentation element SHALL use the representation term Augmentation.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>Within the schema, the name of a metadata element SHALL use the representation term <code>Metadata</code>.</p>
    </rule>
    <rule applicability="REF SUB EXT">
      <p>Within the schema, the name of a role SHALL use the property term <code>RoleOf</code>.</p>
    </rule>
  </section>
  <section>
    <title>Pushed-off rules</title>
    <definition term="NIEM-conformant schema">
      <p>An XML Schema document is a <strong>NIEM-conformant schema</strong> if and only if it is a reference schema, a subset schema, an extension schema, an exchange schema, or a constraint schema.</p>
    </definition>
    <definition term="NIEM-conformant component">
      <p>A <strong>NIEM-conformant component</strong> is an XML Schema component that is defined by a reference schema, an extension schema, or an exchange schema.</p>
    </definition>
    <definition term="reference schema">
      <p>A reference schema is an XML Schema document that meets all of the following criteria:</p>
      <ul>
        <li>
          <p>It is explicitly designated as a reference schema. This may be declared by an IEPD catalog or by a tool-specific mechanism outside the schema.</p>
        </li>
        <li>
          <p>It provides the broadest, most fundamental definitions of components in its namespace.</p>
        </li>
        <li>
          <p>It provides the authoritative definition of business semantics for components in its namespace.</p>
        </li>
        <li>
          <p>It is intended to serve as the basis for components in IEPD schemas, including subset schemas, constraint schemas, extension schemas, and exchange schemas.</p>
        </li>
        <li>
          <p>It satisfies all rules specified in the Naming and Design Rules for reference schemas.</p>
        </li>
      </ul>
    </definition>
    <definition term="subset schema">
      <p>A subset schema is an XML Schema document that meets all of the following criteria:</p>
      <ul>
        <li>
          <p>It is explicitly designated as a subset schema. This may be declared by an IEPD catalog or by a tool-specific mechanism outside the schema.</p>
        </li>
        <li>
          <p>It has a target namespace previously defined by a reference schema. That is, it does not provide original definitions for schema components, but instead provides an alternate schema representation of components that are defined by a reference schema.</p>
        </li>
        <li>
          <p>It does not alter the business semantics of components in its namespace. The reference schema defines these business semantics.</p>
        </li>
        <li>
          <p>It is intended to express the limited vocabulary necessary for an IEPD and to support XML Schema validation for an IEPD.</p>
        </li>
        <li>
          <p>It satisfies all rules specified in the Naming and Design Rules for subset schemas.</p>
        </li>
      </ul>
    </definition>
    <definition term="extension schema">
      <p>An extension schema is an XML Schema document that meets all of the following criteria:</p>
      <ul>
        <li>
          <p>It is explicitly designated as an extension schema. This may be declared by an IEPD catalog or by a tool-specific mechanism outside the schema.</p>
        </li>
        <li>
          <p>It provides the broadest, most fundamental definitions of components in its namespace.</p>
        </li>
        <li>
          <p>It provides the authoritative definition of business semantics for components in its namespace.</p>
        </li>
        <li>
          <p>It contains components that, when appropriate, use or are derived from the components in reference schemas or exchange schemas. When a reference schema contains relevant components, it is preferred to an exchange schema.</p>
        </li>
        <li>
          <p>It is intended to express the additional vocabulary required for an IEPD, above and beyond the vocabulary available from reference schemas, and to support XML Schema validation for an IEPD.</p>
        </li>
        <li>
          <p>It satisfies all rules specified in the Naming and Design Rules for extension schemas.</p>
        </li>
      </ul>
    </definition>
    <definition term="exchange schema">
      <p>An exchange schema is an XML Schema document that meets all of the following criteria:</p>
      <ul>
        <li>
          <p>It is explicitly designated as an exchange schema. This may be declared by an IEPD catalog or by a tool-specific mechanism outside the schema.</p>
        </li>
        <li>
          <p>It provides the broadest, most fundamental definitions of components in its namespace.</p>
        </li>
        <li>
          <p>It provides the authoritative definition of business semantics for components in its namespace.</p>
        </li>
        <li>
          <p>It contains components that use or are derived from the components in reference schemas or exchange schemas.</p>
        </li>
        <li>
          <p>It is intended to identify and define the document element information item for a particular information exchange that is described by an IEPD.</p>
        </li>
        <li>
          <p>It satisfies all rules specified in the Naming and Design Rules for exchange schemas.</p>
        </li>
      </ul>
    </definition>
    <definition term="constraint schema">
      <p>A constraint schema is an XML Schema document that meets all of the following criteria:</p>
      <ul>
        <li>
          <p>It is explicitly designated as a constraint schema. This may be declared by an IEPD catalog or by a tool-specific mechanism outside the schema.</p>
        </li>
        <li>
          <p>It contains XML Schema components that exist for the purpose of (1) determining schema-validity of XML documents according to some criteria not easily expressed in other classes of schema documents, and (2) expressing those criteria in the XML Schema definition language.</p>
        </li>
        <li>
          <p>It has a target namespace previously defined by a reference schema, extension schema, or exchange schema, or it is intended to support a constraint schema that does have such a target namespace.</p>
        </li>
        <li>
          <p>It is intended to express business rules for a class of XML documents, not the semantics of those XML documents.</p>
        </li>
        <li>
          <p>It satisfies all rules specified in the Naming and Design Rules for constraint schemas.</p>
        </li>
      </ul>
    </definition>
    <definition term="NIEM-conformant XML document">
      <p>A NIEM-conformant XML document is an XML document that satisfies all of the following criteria:</p>
      <ul>
        <li>
          <p>The document element is locally schema-valid.</p>
        </li>
        <li>
          <p>Each element information item within the XML document that has a namespace name matching the target namespace of a reference schema, extension schema, or exchange schema is a NIEM-conformant element information item.</p>
        </li>
      </ul>
    </definition>
    <definition term="NIEM-conformant element information item">
      <p>A NIEM-conformant element information item is an element information item that satisfies all of the following criteria:</p>
      <ul>
        <li>
          <p>Its namespace name and local name matches an element declared by a reference schema, extension schema, or exchange schema.</p>
        </li>
        <li>
          <p>It occurs within a NIEM-conformant XML document.</p>
        </li>
        <li>
          <p>It is locally schema-valid.</p>
        </li>
        <li>
          <p>It satisfies all rules specified in the Naming and Design Rules for NIEM-conformant element information items.</p>
        </li>
      </ul>
    </definition>
    <principle>
      <p>This specification SHOULD specify what is necessary for semantic interoperability and no more.</p>
    </principle>
    <principle>
      <p>This specification SHOULD focus on providing rules for specifying schemas.</p>
    </principle>
    <principle>
      <p>This specification SHOULD feature rules thatare as specific, precise, and concise as possible.</p>
    </principle>
    <principle>
      <p>The content of a NIEM-conformant data instance SHOULD NOT be modified by processing against XML Schema documents.</p>
    </principle>
    <principle>
      <p>NIEM-conformant schemas and NIEM-conformant XML documents SHOULD use XML Schema validating parsers for validation of XML content.</p>
    </principle>
    <principle>
      <p>Systems that use NIEM-conformant data SHOULD mark as invalid data that does not conform to the rules defined by applicable XML Schema documents.</p>
    </principle>
    <principle>
      <p>Constraints on XML instances MAY be validated by multiple schema validation passes, using multiple schemas for a single namespace.</p>
    </principle>
    <principle>
      <p>Each NIEM-conformant namespace SHOULD be defined by exactly one reference schema.</p>
    </principle>
    <principle>
      <p>NIEM-conformant schemas SHOULD NOT specify data that uses mixed content.</p>
    </principle>
    <principle>
      <p>NIEM-conformant schemas SHOULD NOT use or define local or anonymous components, as they adversely affect reuse.</p>
    </principle>
    <principle>
      <p>NIEM-conformant components SHOULD NOT incorporate wildcards unless absolutely necessary, as they hinder standardization by encouraging use of nonstandardized data rather than standardized data.</p>
    </principle>
    <principle>
      <p>Schema locations specified within NIEM-conformant reference schemas SHOULD be interpreted as hints and as default values by processing applications.</p>
    </principle>
    <principle>
      <p>NIEM standards and schemas SHOULD leverage and enable use of other open standards.</p>
    </principle>
    <principle>
      <p>NIEM-conformant instances and schemas SHOULD reuse components from NIEM distribution schemas when possible.</p>
    </principle>
    <principle>
      <p>A component SHOULD be identified by its local name together with its namespace. A namespace SHOULD be a required part of the name of a component. A component<char name="rsquo"/>s local name SHOULD NOT imply a relationship to components with similar names from other namespaces.</p>
    </principle>
    <principle>
      <p>NIEM-conformant schemas and standards SHOULD be designed to encourage and ease extension and augmentation by users and developers outside the standardization process.</p>
    </principle>
    <principle>
      <p>XML data SHOULD be designed for automatic processing. XML data SHOULD NOT be designed for literal presentation to people. NIEM standards and schemas SHOULD NOT use literal presentation to people as a design criterion.</p>
    </principle>
    <principle>
      <p>NIEM SHOULD NOT depend on specific software packages, software frameworks, or software systems for interpretation of XML instances.</p>
    </principle>
    <principle>
      <p>NIEM schemas and standards SHOULD be designed such that software systems that use NIEM may be built with a variety of off-the-shelf and free software products.</p>
    </principle>
    <principle>
      <p>A data component definition SHOULD be drafted before the associated data element name is composed.</p>
    </principle>
    <principle>
      <p>Components in NIEM SHOULD be given names that are consistent with names of other NIEM components. Such names SHOULD be based on simple rules.</p>
    </principle>
    <principle>
      <p>Component definitions in NIEM-conformant schemas SHOULD reflect real-world concepts.</p>
    </principle>
    <principle>
      <p>Component definitions in NIEM-conformant schemas SHOULD have semantic consistency.</p>
    </principle>
    <principle>
      <p>Complex type definitions in NIEM-conformant schemas SHOULD use type inheritance only for specialization.</p>
    </principle>
    <principle>
      <p>Multiple components with identical or undifferentiated semantics SHOULD NOT be defined. Component definitions SHOULD have clear, explicit distinctions.</p>
    </principle>
    <principle>
      <p>NIEM-conformant schemas SHOULD have the simplest possible structure, content, and architecture consistent with real business requirements.</p>
    </principle>
    <principle>
      <p>Components defined by NIEM-conformant schemas SHOULD be defined appropriate for their scope.</p>
    </principle>
    <principle>
      <p>XML namespaces defined by NIEM-conformant schemas SHOULD encapsulate data components that are coherent, consistent, and internally related as a set. A namespace SHOULD encapsulate components that tend to change together.</p>
    </principle>

    <rule applicability="REF SUB EXT">
      <p>A NIEM component name SHALL be formed by applying the informative
      guidelines and examples detailed in Annex A of <ref idref="ISO11179Part5"/>, with 
      exceptions as specified in this
      document, most notably those specified in Section 9, Naming Rules.</p>
    </rule>

  </section>
  <section>
    <title>Deleted rules</title>
    
    <rule applicability="REF SUB EXT">
      <p>Within the schema, an element declaration that is of complex content SHALL
      NOT own the attribute <code>mixed</code> with the value <code>true</code>.</p>
    </rule>

  </section>
  <section>  
    <title>References</title>
    <reference id="ISO11179Part4">
      <p>ISO/IEC 11179-4:2004, Information technology <char name="mdash"/> Metadata registries (MDR) <char name="mdash"/> Part 4: Formulation of data definitions. Available from <link>http://standards.iso.org/ittf/PubliclyAvailableStandards/c035346_ISO_IEC_11179-4_2004(E).zip</link>.</p>
    </reference>
    <reference id="ISO11179Part5">
      <p>ISO/IEC 11179-5:2005, Information technology <char name="mdash"/> Metadata registries (MDR) <char name="mdash"/> Part 5: Naming and identification principles. Available from <link>http://standards.iso.org/ittf/PubliclyAvailableStandards/c035347_ISO_IEC_11179-5_2005(E).zip</link>.</p>
    </reference>
    <reference id="OED">
      <p>Oxford English Dictionary, Second Edition, 1989. Available from <link>http://dictionary.oed.com/</link>.</p>
    </reference>
    <reference id="RFC2119">
      <p>Bradner, S. Key words for use in RFCs to Indicate Requirement Levels, IETF RFC 2119, March 1997. Available from <link>http://www.ietf.org/rfc/rfc2119.txt</link>.</p>
    </reference>
    <reference id="RFC3986">
      <p>Berners-Lee, T., et al.: Uniform Resource Identifier (URI): Generic Syntax, Request for Comments 3986, January 2005. Available from <link>http://www.ietf.org/rfc/rfc3986.txt</link>.</p>
    </reference>
    <reference id="XML">
      <p>Extensible Markup Language (XML) 1.0 (Fourth Edition), W3C Recommendation 16 August 2006. Available from <link>http://www.w3.org/TR/2006/REC-xml-20060816/</link>.</p>
      <p>EBNF notation is described at <link href="http://www.w3.org/TR/2006/REC-xml-20060816/#sec-notation">#sec-notation</link>.</p>
      <p>IDREF constraint is described at <link href="http://www.w3.org/TR/2006/REC-xml-20060816/#idref">#idref</link>.</p>
    </reference>
    <reference id="XMLInfoSet">
      <p>XML Information Set (Second Edition), W3C Recommendation 4 February 2004. Available from <link>http://www.w3.org/TR/2004/REC-xml-infoset-20040204/</link>.</p>
    </reference>
    <reference id="XMLNamespaces">
      <p>Namespaces in XML, World Wide Web Consortium 16 August 2006. Available from <link>http://www.w3.org/TR/2006/REC-xml-names-20060816</link>.</p>
      <p>NCName is described at <link href="http://www.w3.org/TR/2006/REC-xml-names-20060816#NT-NCName">#NT-NCName</link>.</p>
    </reference>
    <reference id="XMLNamespacesErrata">
      <p>Namespaces in XML Errata, 6 December 2002. Available from <link>http://www.w3.org/XML/xml-names-19990114-errata</link>.</p>
    </reference>
    <reference id="XMLSchemaDatatypes">
      <p>XML Schema Part 2: Datatypes Second Edition, W3C Recommendation 28 October 2004. Available at <link>http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/</link>.</p>
    </reference>
    <reference id="XMLSchemaStructures">
      <p>XML Schema Part 1: Structures Second Edition, W3C Recommendation 28 October 2004. Available from <link>http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/</link>.</p>
      <p>Annotations are described at <link href="http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/#Annotation_details">#Annotation_details</link>.</p>
    </reference>
    <reference id="XSLT">
      <p>XSL Transformations (XSLT), Version 1.0, W3C Recommendation 16 November 1999. Available from <link>http://www.w3.org/TR/1999/REC-xslt-19991116/</link>.</p>
      <p>The element <code>xsl:sort</code> is described at <link href="http://www.w3.org/TR/1999/REC-xslt-19991116/#element-sort">#element-sort</link>.</p>
    </reference>
    <reference id="CTAS">
      <p>NIEM Conformance Targets Attribute Specification, Version 3.0, August 1, 2012.<todo>revise to released version of CTAS</todo></p>
    </reference>
    <reference id="Schematron">
      <p>ISO/IEC STANDARD 19757-3: Information technology — Document Schema Definition Languages (DSDL) Part 3: Rule-based validation — Schematron. (2006, June 1). ISO/IEC. Retrieved from <link>http://standards.iso.org/ittf/PubliclyAvailableStandards/c040833_ISO_IEC_19757-3_2006(E).zip</link></p>
    </reference>
  </section>
</document>
<!-- 
     Local Variables:
     mode: sgml
     indent-tabs-mode: nil
     fill-column: 80
     End:
  -->
